{"meta":{"title":"骸の博客","subtitle":"每天进步一丢丢","description":"为了梦想而努力","author":"胡歌的小迷弟","url":"https://haikulou1.github.io","root":"/"},"pages":[{"title":"about","date":"2019-09-20T12:58:27.000Z","updated":"2019-09-20T13:18:06.122Z","comments":true,"path":"about/index.html","permalink":"https://haikulou1.github.io/about/index.html","excerpt":"","text":"一个有梦想的程序猿"},{"title":"archives","date":"2019-09-20T12:59:24.000Z","updated":"2019-09-20T13:01:34.158Z","comments":true,"path":"archives/index.html","permalink":"https://haikulou1.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-20T12:59:13.000Z","updated":"2019-09-20T13:01:55.009Z","comments":true,"path":"categories/index.html","permalink":"https://haikulou1.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-20T12:58:36.000Z","updated":"2019-09-20T13:02:11.243Z","comments":true,"path":"tags/index.html","permalink":"https://haikulou1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序算法总结","slug":"排序算法总结","date":"2019-10-09T13:37:01.000Z","updated":"2019-10-09T13:40:22.608Z","comments":true,"path":"2019/10/09/排序算法总结/","link":"","permalink":"https://haikulou1.github.io/2019/10/09/排序算法总结/","excerpt":"","text":"相关术语解释： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 n: 数据规模 k: “桶”的个数 In-place: 不占用额外内存 Out-place: 占用额外内存","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"}]},{"title":"数据结构排序之基数排序","slug":"数据结构排序之基数排序","date":"2019-10-09T12:37:23.000Z","updated":"2019-10-09T13:35:50.052Z","comments":true,"path":"2019/10/09/数据结构排序之基数排序/","link":"","permalink":"https://haikulou1.github.io/2019/10/09/数据结构排序之基数排序/","excerpt":"算法思想 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列","text":"算法思想 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Created by 胡歌的小迷弟 on 2019/9/25 16:12 */ public class 基数排序 &#123; public static void main(String[] args) &#123; int a[] = &#123; 53, 3, 542, 748, 14, 214&#125;; sort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; public static void sort(int arr[])&#123; //根据前面的推导过程，我们可以得到最终的基数排序代码 //1. 得到数组中最大的数的位数 int max = arr[0]; //假设第一数就是最大数 for(int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //得到最大数是几位数 int maxLength = (max + \"\").length(); //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组 //说明 //1. 二维数组包含10个一维数组 //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length //3. 名明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 //可以这里理解 //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; //这里我们使用循环将代码处理 for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) &#123; //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位.. for(int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素的对应位的值 int digitOfElement = arr[j] / n % 10; //放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123; //如果桶中，有数据，我们才放入到原数组 if(bucketElementCounts[k] != 0) &#123; //循环该桶即第k个桶(即第k个一维数组), 放入 for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; //System.out.println(\"第\"+(i+1)+\"轮，对个位的排序处理 arr =\" + Arrays.toString(arr)); &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"基数排序","slug":"数据结构/排序/基数排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/基数排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"基数排序","slug":"基数排序","permalink":"https://haikulou1.github.io/tags/基数排序/"}]},{"title":"数据结构排序之归并排序","slug":"数据结构排序之归并排序","date":"2019-10-09T12:08:50.000Z","updated":"2019-10-09T12:37:00.989Z","comments":true,"path":"2019/10/09/数据结构排序之归并排序/","link":"","permalink":"https://haikulou1.github.io/2019/10/09/数据结构排序之归并排序/","excerpt":"算法思想 建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列","text":"算法思想 建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 /** * Created by 胡歌的小迷弟 on 2019/10/9 20:14 */public class 归并排序 &#123; public static void main(String[] args) &#123; int [] a=&#123;8,4,5,7,1,3,6,2&#125;; int temp[]=new int[a.length]; mergeSort(a,0,a.length-1,temp); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; //分+合方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if(left &lt; right) &#123; int mid = (left + right) / 2; //中间索引 //向左递归进行分解 mergeSort(arr, left, mid, temp); //向右递归进行分解 mergeSort(arr, mid + 1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; &#125; //合并的方法 /** * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 初始化i, 左边有序序列的初始索引 int j = mid + 1; //初始化j, 右边有序序列的初始索引 int t = 0; // 指向temp数组的当前索引 //(一) //先把左右两边(有序)的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续 //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充到 temp数组 //然后 t++, i++ if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组 temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; //(二) //把有剩余数据的一边的数据依次全部填充到temp while (i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t += 1; j += 1; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"归并排序","slug":"数据结构/排序/归并排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/归并排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"归并排序","slug":"归并排序","permalink":"https://haikulou1.github.io/tags/归并排序/"}]},{"title":"数据结构排序之快速排序","slug":"数据结构排序之快速排序","date":"2019-10-08T13:33:19.000Z","updated":"2019-10-08T13:36:07.159Z","comments":true,"path":"2019/10/08/数据结构排序之快速排序/","link":"","permalink":"https://haikulou1.github.io/2019/10/08/数据结构排序之快速排序/","excerpt":"快速排序基本思想 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列","text":"快速排序基本思想 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Created by 胡歌的小迷弟 on 2019/10/8 20:48 */public class 快速排序 &#123; public static void main(String[] args) &#123; int arr[]=&#123;-9,78,0,23,-567,70&#125;; sort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; private static void sort(int[] arr,int left,int right) &#123; int l=left; int r=right; int pivot = arr[(left + right) / 2]; int temp = 0; //临时变量，作为交换时使用 while( l &lt; r) &#123; //在pivot的左边一直找,找到大于等于pivot值,才退出 while( arr[l] &lt; pivot) &#123; l += 1; &#125; //在pivot的右边一直找,找到小于等于pivot值,才退出 while(arr[r] &gt; pivot) &#123; r -= 1; &#125; //如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是 //小于等于pivot值，右边全部是大于等于pivot值 if( l &gt;= r) &#123; break; &#125; //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移 if(arr[l] == pivot) &#123; r -= 1; &#125; //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移 if(arr[r] == pivot) &#123; l += 1; &#125; &#125; // 如果 l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if(left &lt; r) &#123; sort(arr, left, r); &#125; //向右递归 if(right &gt; l) &#123; sort(arr, l, right); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"快速排序","slug":"数据结构/排序/快速排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/快速排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"快速排序","slug":"快速排序","permalink":"https://haikulou1.github.io/tags/快速排序/"}]},{"title":"数据结构排序之希尔排序","slug":"数据结构排序之希尔排序","date":"2019-10-08T13:26:02.000Z","updated":"2019-10-08T13:32:40.425Z","comments":true,"path":"2019/10/08/数据结构排序之希尔排序/","link":"","permalink":"https://haikulou1.github.io/2019/10/08/数据结构排序之希尔排序/","excerpt":"算法思想 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。","text":"算法思想 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 123456789101112131415161718192021222324252627282930313233public class 希尔排序 &#123; public static void main(String[] args) &#123; int [] a=&#123;8,9,1,7,2,3,5,4,6,0&#125;; sort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; private static void sort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j-gap]; j -= gap; &#125; //当退出while后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"希尔排序","slug":"数据结构/排序/希尔排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/希尔排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"希尔排序","slug":"希尔排序","permalink":"https://haikulou1.github.io/tags/希尔排序/"}]},{"title":"数据结构之排序之插入排序","slug":"数据结构之排序之插入排序","date":"2019-09-25T11:56:24.000Z","updated":"2019-09-26T01:24:04.723Z","comments":true,"path":"2019/09/25/数据结构之排序之插入排序/","link":"","permalink":"https://haikulou1.github.io/2019/09/25/数据结构之排序之插入排序/","excerpt":"插入排序算法思想插入排序的基本思想是:把n个待排序的元素看出一个有序表和一个无序表，开始是有序表只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。","text":"插入排序算法思想插入排序的基本思想是:把n个待排序的元素看出一个有序表和一个无序表，开始是有序表只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 1234567891011121314151617181920212223242526272829303132333435/** * Created by 胡歌的小迷弟 on 2019/9/25 16:12 */public class InsertSort &#123; public static void main(String[] args) &#123; int a[]=&#123;3,9,-1,10,-2&#125;; insertSort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; public static void insertSort(int[] arr) &#123; int insertVal = 0; int insertIndex = 0; //使用for循环来把代码简化 for(int i=1;i&lt;arr.length;i++)&#123; insertVal=arr[i]; insertIndex=i-1; while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123; arr[insertIndex+1]=arr[insertIndex]; insertIndex--; &#125; if(insertIndex!=i+1)&#123; arr[insertIndex+1]=insertVal; &#125; //System.out.println(\"第\"+i+\"轮插入\"); //System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"插入排序","slug":"数据结构/排序/插入排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/插入排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"插入排序","slug":"插入排序","permalink":"https://haikulou1.github.io/tags/插入排序/"}]},{"title":"数据结构之排序之选择排序","slug":"数据结构之排序之选择排序","date":"2019-09-25T09:07:55.000Z","updated":"2019-10-06T02:18:03.557Z","comments":true,"path":"2019/09/25/数据结构之排序之选择排序/","link":"","permalink":"https://haikulou1.github.io/2019/09/25/数据结构之排序之选择排序/","excerpt":"","text":"简单选择排序算法思路 每一趟在后面n-i-1个代排元素选取关键字最小的元素。 12345678910111213141516171819202122232425262728293031public class SimSelcet &#123; public static void main(String[] args) &#123; int a[]=&#123;8,3,2,1,7,4,6,5&#125;; sort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; static int index=0; static int tmep=0; public static void sort(int a[])&#123; for(int i=0;i&lt;a.length;i++)&#123; index=i; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[j]&lt;a[index])&#123; index=j; &#125; if(index!=i)&#123; tmep=a[i]; a[i]=a[index]; a[index]=tmep; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"选择排序","slug":"数据结构/排序/选择排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/选择排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"选择排序","slug":"选择排序","permalink":"https://haikulou1.github.io/tags/选择排序/"}]},{"title":"数据结构之排序之冒泡排序","slug":"数据结构之排序之冒泡排序","date":"2019-09-25T08:06:57.000Z","updated":"2019-09-25T12:11:46.913Z","comments":true,"path":"2019/09/25/数据结构之排序之冒泡排序/","link":"","permalink":"https://haikulou1.github.io/2019/09/25/数据结构之排序之冒泡排序/","excerpt":"冒泡排序基本思想 通过比较相邻的关键字间的大小，来对相应关键字的顺序进行交换，每趟排序都能找出最大或者最小的关键字放在数组末尾。","text":"冒泡排序基本思想 通过比较相邻的关键字间的大小，来对相应关键字的顺序进行交换，每趟排序都能找出最大或者最小的关键字放在数组末尾。 123456789101112131415161718192021222324252627 /** * Created by 胡歌的小迷弟 on 2019/9/25 16:12 */public class Maopaosort &#123; public static void main(String[] args) &#123; int a[]=&#123;3,9,-1,10,-2&#125;; sort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; static int temp=0; public static void sort(int a[])&#123; for(int i=0;i&lt;a.length;i++)&#123; for(int j=0;j&lt;a.length-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; &#125;&#125; 冒泡排序的小优化 12345678910111213141516171819202122232425262728293031323334 /** * Created by 胡歌的小迷弟 on 2019/9/25 16:12 */public class Maopaosort &#123; public static void main(String[] args) &#123; int a[]=&#123;3,9,-1,10,-2&#125;; sort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; &#125; boolean flag=false; //判断当前循环是否有交换 static int temp=0; public static void sort(int a[])&#123; for(int i=0;i&lt;a.length;i++)&#123; for(int j=0;j&lt;a.length-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; flag=true; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; if(!flag)&#123; break;//在一次交换中没有一次交换发生过 &#125;else&#123; flag=false;//重置flag，进行下次判断 &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/"},{"name":"冒泡排序","slug":"数据结构/排序/冒泡排序","permalink":"https://haikulou1.github.io/categories/数据结构/排序/冒泡排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"https://haikulou1.github.io/tags/排序/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://haikulou1.github.io/tags/冒泡排序/"}]},{"title":"java基础之集合之set之HashSet","slug":"java基础之集合之set之HashSet","date":"2019-09-25T02:59:31.000Z","updated":"2019-09-25T03:00:25.141Z","comments":true,"path":"2019/09/25/java基础之集合之set之HashSet/","link":"","permalink":"https://haikulou1.github.io/2019/09/25/java基础之集合之set之HashSet/","excerpt":"","text":"HashSet 哈希表边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法 如果 equls结果为true ，HashSet就视为同一个元素。如果equals 为false就不是同一个元素。 哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。左图表示hashCode值不相同的情况；右图表示hashCode值相同，但equals不相同的情况。 HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"},{"name":"集合","slug":"java/java基础/集合","permalink":"https://haikulou1.github.io/categories/java/java基础/集合/"},{"name":"HashSet","slug":"java/java基础/集合/HashSet","permalink":"https://haikulou1.github.io/categories/java/java基础/集合/HashSet/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"},{"name":"集合","slug":"集合","permalink":"https://haikulou1.github.io/tags/集合/"},{"name":"HashSet","slug":"HashSet","permalink":"https://haikulou1.github.io/tags/HashSet/"}]},{"title":"java基础之集合之Map之HashMap","slug":"java基础之集合之HashMap","date":"2019-09-23T11:48:14.000Z","updated":"2019-10-08T02:49:31.843Z","comments":true,"path":"2019/09/23/java基础之集合之HashMap/","link":"","permalink":"https://haikulou1.github.io/2019/09/23/java基础之集合之HashMap/","excerpt":"Set注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。","text":"Set注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。 HashMapHashMap的结构jdk1.7与1.8不同点 （1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。 （2）扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1） （3）而在JDK1.8的时候，用扩容前的原始位置+扩容的大小值的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。 扩容流程对比图: JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率） 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键 为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化 参考：https://blog.csdn.net/qq_36520235/article/details/82417949","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"},{"name":"集合","slug":"java/java基础/集合","permalink":"https://haikulou1.github.io/categories/java/java基础/集合/"},{"name":"HashMap","slug":"java/java基础/集合/HashMap","permalink":"https://haikulou1.github.io/categories/java/java基础/集合/HashMap/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"},{"name":"集合","slug":"集合","permalink":"https://haikulou1.github.io/tags/集合/"},{"name":"HashMap","slug":"HashMap","permalink":"https://haikulou1.github.io/tags/HashMap/"}]},{"title":"java基础之集合之List","slug":"java基础之集合之List","date":"2019-09-22T12:45:50.000Z","updated":"2019-09-23T11:45:49.598Z","comments":true,"path":"2019/09/22/java基础之集合之List/","link":"","permalink":"https://haikulou1.github.io/2019/09/22/java基础之集合之List/","excerpt":"","text":"ArrayList ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除 底层实现原理1.当我们new 一个ArrayList时，不传size时，往list中add第一个数据时，ArrayList就会new一个默认大小为10的数组。 123456789101112131415161718192021public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private static final int DEFAULT_CAPACITY = 10; 2.当继续往list添加数据时,当添加的数据大于当前数组的大小时，就会将旧数组的数据复制到一个1.5倍大小的新的数组。 12345678910111213141516171819private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//newCapacity =1.5*oldCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 3.然而删除数据不会自动缩容 Vector Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 底层实现原理1.当我们new 一个 Vector时，就会自动创建一个默认大小为10的的数组 123456789101112131415161718public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125; public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;public Vector() &#123; this(10);&#125; 2.Vector中的方法是同步的。Vector的所有操作方法都被同步了，既然被同步了，多个线程就不可能同时访问vector中的数据，只能一个一个地访问，所以不会出现数据混乱的情况，所以是线程安全的。 1234567891011121314151617181920212223public synchronized int capacity() &#123; return elementData.length; &#125; /** * Returns the number of components in this vector. * * @return the number of components in this vector */ public synchronized int size() &#123; return elementCount; &#125; /** * Tests if this vector has no components. * * @return &#123;@code true&#125; if and only if this vector has * no components, that is, its size is zero; * &#123;@code false&#125; otherwise. */ public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; LinkedList LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 1.底层使用双向链表实现 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"},{"name":"集合","slug":"java/java基础/集合","permalink":"https://haikulou1.github.io/categories/java/java基础/集合/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"},{"name":"集合","slug":"集合","permalink":"https://haikulou1.github.io/tags/集合/"}]},{"title":"java基础之集合","slug":"java基础之集合","date":"2019-09-22T12:09:50.000Z","updated":"2019-09-22T12:44:40.476Z","comments":true,"path":"2019/09/22/java基础之集合/","link":"","permalink":"https://haikulou1.github.io/2019/09/22/java基础之集合/","excerpt":"集合集合类存在放java.util包中，主要有set，list，map。 Collection：Collection是集合List、Set、Queue的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口","text":"集合集合类存在放java.util包中，主要有set，list，map。 Collection：Collection是集合List、Set、Queue的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口 集合之间继承和实现关系:","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"}]},{"title":"递归之8皇后问题","slug":"递归之8皇后问题","date":"2019-09-22T12:02:16.000Z","updated":"2019-09-22T12:07:35.264Z","comments":true,"path":"2019/09/22/递归之8皇后问题/","link":"","permalink":"https://haikulou1.github.io/2019/09/22/递归之8皇后问题/","excerpt":"八皇后问题介绍 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。","text":"八皇后问题介绍 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 八皇后问题算法思路分析1.第一个皇后先放第一行第一列 2.第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 3.继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到. 5.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class EightQueue &#123; static int array[]=new int[8]; static int count=0; public static void main(String[]args)&#123; check(0); System.out.printf(\"一共有%d解法\", count); &#125; //编写一个方法，放置第n个皇后 //特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private static void check(int n) &#123; if(n == 8) &#123; //n = 8 , 其实8个皇后就既然放好 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i = 0; i &lt; 8; i++) &#123; //先把当前这个皇后 n , 放到该行的第1列 array[n] = i; //判断当放置第n个皇后到i列时，是否冲突 if(judge(n)) &#123; // 不冲突 //接着放n+1个皇后,即开始递归 check(n+1); // &#125; //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置 &#125; &#125; public static boolean judge(int n)&#123; for(int i=0;i&lt;n;i++)&#123; // 说明 //1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 // n = 1 放置第 2列 1 n = 1 array[1] = 1 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if(array[n]==array[i]||(Math.abs(i-n)==Math.abs(array[n]-array[i])))&#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private static void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"递归","slug":"数据结构/递归","permalink":"https://haikulou1.github.io/categories/数据结构/递归/"},{"name":"回溯","slug":"数据结构/递归/回溯","permalink":"https://haikulou1.github.io/categories/数据结构/递归/回溯/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"递归","slug":"递归","permalink":"https://haikulou1.github.io/tags/递归/"},{"name":"回溯","slug":"回溯","permalink":"https://haikulou1.github.io/tags/回溯/"}]},{"title":"java基础之基本特性","slug":"java基础之基本特性","date":"2019-09-21T13:16:16.000Z","updated":"2019-09-22T11:59:15.634Z","comments":true,"path":"2019/09/21/java基础之基本特性/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/java基础之基本特性/","excerpt":"基本特性1.抽象 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象有哪些行为，并不关心这些行为的细节是什么。","text":"基本特性1.抽象 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象有哪些行为，并不关心这些行为的细节是什么。 2.继承 继承是从已有类别得到继承信息创建新类的过程，提供继承信息的类被称为父类（超类，基类），得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 3.多态 多态是指允许不同子类型的对象对同一消息做出不同的反应 Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 重写（override)又名覆盖: 1.不能存在同一个类中，在继承或实现关系的类中； 2.名相同，参数列表相同，方法返回值相同， 3.子类方法的访问修饰符要大于父类的。 4.子类的检查异常类型要小于父类的检查异常。 重载（overload） 1.可以在一个类中也可以在继承关系的类中； 2.名相同； 3.参数列表不同（个数，顺序，类型） 和方法的返回值类型无关。 4.封装 封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"}]},{"title":"java基础(基本数据类型)","slug":"java基础","date":"2019-09-21T12:33:14.000Z","updated":"2019-09-21T13:16:51.979Z","comments":true,"path":"2019/09/21/java基础/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/java基础/","excerpt":"java 8种基本类型 类型 在内存中占的字节数 默认值 boolean 1 false byte 1 0 short 2 0 int 4 0 long 8 0 char 1 \\u0000 float 4 0.0f double 8 0.0d","text":"java 8种基本类型 类型 在内存中占的字节数 默认值 boolean 1 false byte 1 0 short 2 0 int 4 0 long 8 0 char 1 \\u0000 float 4 0.0f double 8 0.0d 装箱和拆箱 自动装箱是Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int 转化成Integer，double 转化成Double，等等。反之就是自动拆箱。 原始类型: boolean，char，byte，short，int，long，float，double 封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double Int 与Integer 区别区别 Integer是int的包装类，int则是java的一种基本数据类型。 Integer变量必须实例化后才能使用，而int变量不需要。 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值。 Integer的默认值是null，int的默认值是0。 疑难杂症1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 12345678910111213Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false```java4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false```javaInteger i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了 字节字符区别字节是存储容量的基本单位，字符是数子，字母，汉子以及其他语言的各种符号。1 字节=8 个二进制单位：一个一个字符由一个字节或多个字节的二进制单位组成。 java 基本类型与引用类型的区别基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所处的位置/地址) 详情:https://blog.csdn.net/qq_26737667/article/details/91398154","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"}]},{"title":"递归","slug":"递归1","date":"2019-09-21T02:59:54.000Z","updated":"2019-09-22T12:00:09.909Z","comments":true,"path":"2019/09/21/递归1/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/递归1/","excerpt":"递归的概念简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。","text":"递归的概念简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。 递归调用机制1234567891011public static void main(String[] args) &#123; test(4); &#125; private static void test(int i) &#123; if(i&gt;2)&#123; test(i-1); &#125; System.out.println(i); &#125; 递归调用过程:1.当程序进入到主函数时会在栈中开辟一个main函数的内存空间，继续调用test(4)。 2.当进入到test(4)时，这时i&gt;2,继续调用test(3),不会执行 System.out.println(i)。 3.依次继续执行直到i&lt;=2,这时会调用System.out.println(i);回调到test(3),直到回调到test(4)函数，main函数执行结束，程序执行完毕。 递归需要遵守的规则1.执行一个新的方法时，就会创建一个新的受保护的独立的栈空间，以便该方法保存本地原始值并引用该方法中的其他对象。 2.方法的局部变量是独立的，不会相互影响，如果方法中使用的是引用类型的变量，就会共享该类型的变量。 3.递归必须要有退出递归的条件，否则就无限递归了。 4.当一个方法执行完毕时，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也执行完毕。 递归用于解决的问题：8皇后问题,汉诺塔,阶乘问题,迷宫问题,快排,归并,二分查找,分治算法。 列子：迷宫问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) &#123; int [][] map=new int[8][7]; // 使用1表示为墙 map[3][1]=1; map[3][2]=1; for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); // 输出地图 System.out.println(\"地图的情况\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; //1. map 表示地图 //2. i,j 表示从地图的哪个位置开始出发 (1,1) //3. 如果小球能到 map[7][6] 位置，则说明通路找到. //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int [][]map,int i,int j)&#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2; // 假定该点是可以走通. if(setWay(map, i+1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay(map, i-1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"递归","slug":"数据结构/递归","permalink":"https://haikulou1.github.io/categories/数据结构/递归/"},{"name":"回溯","slug":"数据结构/递归/回溯","permalink":"https://haikulou1.github.io/categories/数据结构/递归/回溯/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"递归","slug":"递归","permalink":"https://haikulou1.github.io/tags/递归/"},{"name":"回溯","slug":"回溯","permalink":"https://haikulou1.github.io/tags/回溯/"}]},{"title":"数据结构之中缀表达式转后缀表达式","slug":"中缀表达式转后缀表达式","date":"2019-09-19T07:52:12.000Z","updated":"2019-09-20T13:48:14.962Z","comments":true,"path":"2019/09/19/中缀表达式转后缀表达式/","link":"","permalink":"https://haikulou1.github.io/2019/09/19/中缀表达式转后缀表达式/","excerpt":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –.","text":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –. 算法思路1.初始化两个栈：运算符栈s1和储存中间结果的栈s2； 2.从左至右扫描中缀表达式； 3.遇到操作数时，将其压s2； 4.遇到运算符时，比较其与s1栈顶运算符的优先级： (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1； (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； 5.遇到括号时： (1) 如果是左括号“(”，则直接压入s1. (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃. 6.重复步骤2至5，直到表达式的最右边. 7.将s1中剩余的运算符依次弹出并压入s2. 8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式. 举列说明中缀表达式为：1+((2+3)*4)-5 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Mid2End &#123;private static int ADD = 1;private static int SUB = 1;private static int MUL = 2;private static int DIV = 2;public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext()) &#123; String str = scanner.nextLine(); List&lt;String &gt;list=min2end(strtolist(str)); for(String s:list)&#123; System.out.print(s+\" \"); &#125; &#125;&#125; //1+((2+3)*4)-5 123+4*5-public static List&lt;String&gt; min2end(List&lt;String&gt; ls)&#123; Stack&lt;String&gt; s1=new Stack&lt;&gt;(); List&lt;String&gt;s2=new ArrayList&lt;&gt;(); for(String s:ls)&#123; if(s.matches(\"\\\\d+\")) &#123; s2.add(s); &#125;else if(s.equals(\"(\"))&#123; s1.push(s); &#125;else if(s.equals(\")\"))&#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while (!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125;else &#123; //当s的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 while(s1.size()!=0&amp;&amp;getValue(s)&lt;=getValue(s1.peek()))&#123; s2.add(s1.pop()); &#125; s1.push(s); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2;&#125; /** * 把数字和符号拆分出来 * @param s * @return */public static List&lt;String&gt; strtolist(String s)&#123; List&lt;String&gt; ls=new ArrayList&lt;&gt;(); int i=0; String str; char c; do &#123; if((c=s.charAt(i))&lt;48||(c=s.charAt(i))&gt;57)&#123; ls.add(c+\"\"); i++; &#125;else &#123; str=\"\"; while (i &lt; s.length() &amp;&amp;(c=s.charAt(i))&gt;=48&amp;&amp;(c=s.charAt(i))&lt;=57)&#123; str+=c; i++; &#125; ls.add(str); &#125; &#125;while (i&lt;s.length()); return ls;&#125;//写一个方法，返回对应的优先级数字public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; &#125; return result;&#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://haikulou1.github.io/categories/数据结构/栈/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"https://haikulou1.github.io/tags/栈/"}]}]}