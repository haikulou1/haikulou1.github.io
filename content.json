{"meta":{"title":"骸の博客","subtitle":"每天进步一丢丢","description":"为了梦想而努力","author":"胡歌的小迷弟","url":"https://haikulou1.github.io","root":"/"},"pages":[{"title":"about","date":"2019-09-20T12:58:27.000Z","updated":"2019-09-20T13:18:06.122Z","comments":true,"path":"about/index.html","permalink":"https://haikulou1.github.io/about/index.html","excerpt":"","text":"一个有梦想的程序猿"},{"title":"archives","date":"2019-09-20T12:59:24.000Z","updated":"2019-09-20T13:01:34.158Z","comments":true,"path":"archives/index.html","permalink":"https://haikulou1.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-20T12:58:36.000Z","updated":"2019-09-20T13:02:11.243Z","comments":true,"path":"tags/index.html","permalink":"https://haikulou1.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-20T12:59:13.000Z","updated":"2019-09-20T13:01:55.009Z","comments":true,"path":"categories/index.html","permalink":"https://haikulou1.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"递归","slug":"递归1","date":"2019-09-21T02:59:54.000Z","updated":"2019-09-21T12:22:12.996Z","comments":true,"path":"2019/09/21/递归1/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/递归1/","excerpt":"递归的概念简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。","text":"递归的概念简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。 递归调用机制1234567891011public static void main(String[] args) &#123; test(4); &#125; private static void test(int i) &#123; if(i&gt;2)&#123; test(i-1); &#125; System.out.println(i); &#125; 递归调用过程:1.当程序进入到主函数时会在栈中开辟一个main函数的内存空间，继续调用test(4)。 2.当进入到test(4)时，这时i&gt;2,继续调用test(3),不会执行 System.out.println(i)。 3.依次继续执行直到i&lt;=2,这时会调用System.out.println(i);回调到test(3),直到回调到test(4)函数，main函数执行结束，程序执行完毕。 递归需要遵守的规则1.执行一个新的方法时，就会创建一个新的受保护的独立的栈空间，以便该方法保存本地原始值并引用该方法中的其他对象。 2.方法的局部变量是独立的，不会相互影响，如果方法中使用的是引用类型的变量，就会共享该类型的变量。 3.递归必须要有退出递归的条件，否则就无限递归了。 4.当一个方法执行完毕时，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也执行完毕。 递归用于解决的问题：8皇后问题,汉诺塔,阶乘问题,迷宫问题,快排,归并,二分查找,分治算法。 列子：迷宫问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) &#123; int [][] map=new int[8][7]; // 使用1表示为墙 map[3][1]=1; map[3][2]=1; for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); // 输出地图 System.out.println(\"地图的情况\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; //1. map 表示地图 //2. i,j 表示从地图的哪个位置开始出发 (1,1) //3. 如果小球能到 map[7][6] 位置，则说明通路找到. //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int [][]map,int i,int j)&#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2; // 假定该点是可以走通. if(setWay(map, i+1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay(map, i-1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"递归","slug":"数据结构/递归","permalink":"https://haikulou1.github.io/categories/数据结构/递归/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"递归","slug":"递归","permalink":"https://haikulou1.github.io/tags/递归/"}]},{"title":"数据结构之中缀表达式转后缀表达式","slug":"中缀表达式转后缀表达式","date":"2019-09-19T07:52:12.000Z","updated":"2019-09-20T13:48:14.962Z","comments":true,"path":"2019/09/19/中缀表达式转后缀表达式/","link":"","permalink":"https://haikulou1.github.io/2019/09/19/中缀表达式转后缀表达式/","excerpt":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –.","text":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –. 算法思路1.初始化两个栈：运算符栈s1和储存中间结果的栈s2； 2.从左至右扫描中缀表达式； 3.遇到操作数时，将其压s2； 4.遇到运算符时，比较其与s1栈顶运算符的优先级： (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1； (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； 5.遇到括号时： (1) 如果是左括号“(”，则直接压入s1. (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃. 6.重复步骤2至5，直到表达式的最右边. 7.将s1中剩余的运算符依次弹出并压入s2. 8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式. 举列说明中缀表达式为：1+((2+3)*4)-5 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Mid2End &#123;private static int ADD = 1;private static int SUB = 1;private static int MUL = 2;private static int DIV = 2;public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext()) &#123; String str = scanner.nextLine(); List&lt;String &gt;list=min2end(strtolist(str)); for(String s:list)&#123; System.out.print(s+\" \"); &#125; &#125;&#125; //1+((2+3)*4)-5 123+4*5-public static List&lt;String&gt; min2end(List&lt;String&gt; ls)&#123; Stack&lt;String&gt; s1=new Stack&lt;&gt;(); List&lt;String&gt;s2=new ArrayList&lt;&gt;(); for(String s:ls)&#123; if(s.matches(\"\\\\d+\")) &#123; s2.add(s); &#125;else if(s.equals(\"(\"))&#123; s1.push(s); &#125;else if(s.equals(\")\"))&#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while (!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125;else &#123; //当s的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 while(s1.size()!=0&amp;&amp;getValue(s)&lt;=getValue(s1.peek()))&#123; s2.add(s1.pop()); &#125; s1.push(s); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2;&#125; /** * 把数字和符号拆分出来 * @param s * @return */public static List&lt;String&gt; strtolist(String s)&#123; List&lt;String&gt; ls=new ArrayList&lt;&gt;(); int i=0; String str; char c; do &#123; if((c=s.charAt(i))&lt;48||(c=s.charAt(i))&gt;57)&#123; ls.add(c+\"\"); i++; &#125;else &#123; str=\"\"; while (i &lt; s.length() &amp;&amp;(c=s.charAt(i))&gt;=48&amp;&amp;(c=s.charAt(i))&lt;=57)&#123; str+=c; i++; &#125; ls.add(str); &#125; &#125;while (i&lt;s.length()); return ls;&#125;//写一个方法，返回对应的优先级数字public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; &#125; return result;&#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://haikulou1.github.io/categories/数据结构/栈/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"https://haikulou1.github.io/tags/栈/"}]}]}