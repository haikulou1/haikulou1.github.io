{"meta":{"title":"骸の博客","subtitle":"每天进步一丢丢","description":"为了梦想而努力","author":"胡歌的小迷弟","url":"https://haikulou1.github.io","root":"/"},"pages":[{"title":"about","date":"2019-09-20T12:58:27.000Z","updated":"2019-09-20T13:18:06.122Z","comments":true,"path":"about/index.html","permalink":"https://haikulou1.github.io/about/index.html","excerpt":"","text":"一个有梦想的程序猿"},{"title":"archives","date":"2019-09-20T12:59:24.000Z","updated":"2019-09-20T13:01:34.158Z","comments":true,"path":"archives/index.html","permalink":"https://haikulou1.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-20T12:58:36.000Z","updated":"2019-09-20T13:02:11.243Z","comments":true,"path":"tags/index.html","permalink":"https://haikulou1.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-20T12:59:13.000Z","updated":"2019-09-20T13:01:55.009Z","comments":true,"path":"categories/index.html","permalink":"https://haikulou1.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构之中缀表达式转后缀表达式","slug":"中缀表达式转后缀表达式","date":"2019-09-19T07:52:12.000Z","updated":"2019-09-20T13:38:24.294Z","comments":true,"path":"2019/09/19/中缀表达式转后缀表达式/","link":"","permalink":"https://haikulou1.github.io/2019/09/19/中缀表达式转后缀表达式/","excerpt":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –.","text":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –. 算法思路1.初始化两个栈：运算符栈s1和储存中间结果的栈s2； 2.从左至右扫描中缀表达式； 3.遇到操作数时，将其压s2； 4.遇到运算符时，比较其与s1栈顶运算符的优先级： (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1； (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； 5.遇到括号时： (1) 如果是左括号“(”，则直接压入s1. (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃. 6.重复步骤2至5，直到表达式的最右边. 7.将s1中剩余的运算符依次弹出并压入s2. 8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式. 举列说明中缀表达式为：1+((2+3)*4)-5 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Mid2End &#123;private static int ADD = 1;private static int SUB = 1;private static int MUL = 2;private static int DIV = 2;public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext()) &#123; String str = scanner.nextLine(); List&lt;String &gt;list=min2end(strtolist(str)); for(String s:list)&#123; System.out.print(s+\" \"); &#125; &#125;&#125; //1+((2+3)*4)-5 123+4*5-public static List&lt;String&gt; min2end(List&lt;String&gt; ls)&#123; Stack&lt;String&gt; s1=new Stack&lt;&gt;(); List&lt;String&gt;s2=new ArrayList&lt;&gt;(); for(String s:ls)&#123; if(s.matches(\"\\\\d+\")) &#123; s2.add(s); &#125;else if(s.equals(\"(\"))&#123; s1.push(s); &#125;else if(s.equals(\")\"))&#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while (!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125;else &#123; //当s的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 while(s1.size()!=0&amp;&amp;getValue(s)&lt;=getValue(s1.peek()))&#123; s2.add(s1.pop()); &#125; s1.push(s); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2;&#125; /** * 把数字和符号拆分出来 * @param s * @return */public static List&lt;String&gt; strtolist(String s)&#123; List&lt;String&gt; ls=new ArrayList&lt;&gt;(); int i=0; String str; char c; do &#123; if((c=s.charAt(i))&lt;48||(c=s.charAt(i))&gt;57)&#123; ls.add(c+\"\"); i++; &#125;else &#123; str=\"\"; while (i &lt; s.length() &amp;&amp;(c=s.charAt(i))&gt;=48&amp;&amp;(c=s.charAt(i))&lt;=57)&#123; str+=c; i++; &#125; ls.add(str); &#125; &#125;while (i&lt;s.length()); return ls;&#125;//写一个方法，返回对应的优先级数字public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; &#125; return result;&#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://haikulou1.github.io/categories/数据结构/栈/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"https://haikulou1.github.io/tags/栈/"}]}]}