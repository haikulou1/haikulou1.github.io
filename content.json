{"meta":{"title":"骸の博客","subtitle":"每天进步一丢丢","description":"为了梦想而努力","author":"胡歌的小迷弟","url":"https://haikulou1.github.io","root":"/"},"pages":[{"title":"about","date":"2019-09-20T12:58:27.000Z","updated":"2019-09-20T13:18:06.122Z","comments":true,"path":"about/index.html","permalink":"https://haikulou1.github.io/about/index.html","excerpt":"","text":"一个有梦想的程序猿"},{"title":"categories","date":"2019-09-20T12:59:13.000Z","updated":"2019-09-20T13:01:55.009Z","comments":true,"path":"categories/index.html","permalink":"https://haikulou1.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-09-20T12:59:24.000Z","updated":"2019-09-20T13:01:34.158Z","comments":true,"path":"archives/index.html","permalink":"https://haikulou1.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-20T12:58:36.000Z","updated":"2019-09-20T13:02:11.243Z","comments":true,"path":"tags/index.html","permalink":"https://haikulou1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java基础之集合","slug":"java基础之集合","date":"2019-09-22T12:09:50.000Z","updated":"2019-09-22T12:40:19.159Z","comments":true,"path":"2019/09/22/java基础之集合/","link":"","permalink":"https://haikulou1.github.io/2019/09/22/java基础之集合/","excerpt":"集合集合类存在放java.util包中，主要有set，list，map。 Collection：Collection是集合List、Set、Queue的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口","text":"集合集合类存在放java.util包中，主要有set，list，map。 Collection：Collection是集合List、Set、Queue的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口 集合之间继承和实现关系:","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"}]},{"title":"递归之8皇后问题","slug":"递归之8皇后问题","date":"2019-09-22T12:02:16.000Z","updated":"2019-09-22T12:07:35.264Z","comments":true,"path":"2019/09/22/递归之8皇后问题/","link":"","permalink":"https://haikulou1.github.io/2019/09/22/递归之8皇后问题/","excerpt":"八皇后问题介绍 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。","text":"八皇后问题介绍 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 八皇后问题算法思路分析1.第一个皇后先放第一行第一列 2.第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 3.继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到. 5.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class EightQueue &#123; static int array[]=new int[8]; static int count=0; public static void main(String[]args)&#123; check(0); System.out.printf(\"一共有%d解法\", count); &#125; //编写一个方法，放置第n个皇后 //特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private static void check(int n) &#123; if(n == 8) &#123; //n = 8 , 其实8个皇后就既然放好 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i = 0; i &lt; 8; i++) &#123; //先把当前这个皇后 n , 放到该行的第1列 array[n] = i; //判断当放置第n个皇后到i列时，是否冲突 if(judge(n)) &#123; // 不冲突 //接着放n+1个皇后,即开始递归 check(n+1); // &#125; //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置 &#125; &#125; public static boolean judge(int n)&#123; for(int i=0;i&lt;n;i++)&#123; // 说明 //1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 // n = 1 放置第 2列 1 n = 1 array[1] = 1 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if(array[n]==array[i]||(Math.abs(i-n)==Math.abs(array[n]-array[i])))&#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private static void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"递归","slug":"数据结构/递归","permalink":"https://haikulou1.github.io/categories/数据结构/递归/"},{"name":"回溯","slug":"数据结构/递归/回溯","permalink":"https://haikulou1.github.io/categories/数据结构/递归/回溯/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"递归","slug":"递归","permalink":"https://haikulou1.github.io/tags/递归/"},{"name":"回溯","slug":"回溯","permalink":"https://haikulou1.github.io/tags/回溯/"}]},{"title":"java基础之基本特性","slug":"java基础之基本特性","date":"2019-09-21T13:16:16.000Z","updated":"2019-09-22T11:59:15.634Z","comments":true,"path":"2019/09/21/java基础之基本特性/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/java基础之基本特性/","excerpt":"基本特性1.抽象 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象有哪些行为，并不关心这些行为的细节是什么。","text":"基本特性1.抽象 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象有哪些行为，并不关心这些行为的细节是什么。 2.继承 继承是从已有类别得到继承信息创建新类的过程，提供继承信息的类被称为父类（超类，基类），得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 3.多态 多态是指允许不同子类型的对象对同一消息做出不同的反应 Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 重写（override)又名覆盖: 1.不能存在同一个类中，在继承或实现关系的类中； 2.名相同，参数列表相同，方法返回值相同， 3.子类方法的访问修饰符要大于父类的。 4.子类的检查异常类型要小于父类的检查异常。 重载（overload） 1.可以在一个类中也可以在继承关系的类中； 2.名相同； 3.参数列表不同（个数，顺序，类型） 和方法的返回值类型无关。 4.封装 封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"}]},{"title":"java基础(基本数据类型)","slug":"java基础","date":"2019-09-21T12:33:14.000Z","updated":"2019-09-21T13:16:51.979Z","comments":true,"path":"2019/09/21/java基础/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/java基础/","excerpt":"java 8种基本类型 类型 在内存中占的字节数 默认值 boolean 1 false byte 1 0 short 2 0 int 4 0 long 8 0 char 1 \\u0000 float 4 0.0f double 8 0.0d","text":"java 8种基本类型 类型 在内存中占的字节数 默认值 boolean 1 false byte 1 0 short 2 0 int 4 0 long 8 0 char 1 \\u0000 float 4 0.0f double 8 0.0d 装箱和拆箱 自动装箱是Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int 转化成Integer，double 转化成Double，等等。反之就是自动拆箱。 原始类型: boolean，char，byte，short，int，long，float，double 封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double Int 与Integer 区别区别 Integer是int的包装类，int则是java的一种基本数据类型。 Integer变量必须实例化后才能使用，而int变量不需要。 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值。 Integer的默认值是null，int的默认值是0。 疑难杂症1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 12345678910111213Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false```java4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false```javaInteger i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了 字节字符区别字节是存储容量的基本单位，字符是数子，字母，汉子以及其他语言的各种符号。1 字节=8 个二进制单位：一个一个字符由一个字节或多个字节的二进制单位组成。 java 基本类型与引用类型的区别基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所处的位置/地址) 详情:https://blog.csdn.net/qq_26737667/article/details/91398154","categories":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"https://haikulou1.github.io/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://haikulou1.github.io/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://haikulou1.github.io/tags/java基础/"}]},{"title":"递归","slug":"递归1","date":"2019-09-21T02:59:54.000Z","updated":"2019-09-22T12:00:09.909Z","comments":true,"path":"2019/09/21/递归1/","link":"","permalink":"https://haikulou1.github.io/2019/09/21/递归1/","excerpt":"递归的概念简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。","text":"递归的概念简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。 递归调用机制1234567891011public static void main(String[] args) &#123; test(4); &#125; private static void test(int i) &#123; if(i&gt;2)&#123; test(i-1); &#125; System.out.println(i); &#125; 递归调用过程:1.当程序进入到主函数时会在栈中开辟一个main函数的内存空间，继续调用test(4)。 2.当进入到test(4)时，这时i&gt;2,继续调用test(3),不会执行 System.out.println(i)。 3.依次继续执行直到i&lt;=2,这时会调用System.out.println(i);回调到test(3),直到回调到test(4)函数，main函数执行结束，程序执行完毕。 递归需要遵守的规则1.执行一个新的方法时，就会创建一个新的受保护的独立的栈空间，以便该方法保存本地原始值并引用该方法中的其他对象。 2.方法的局部变量是独立的，不会相互影响，如果方法中使用的是引用类型的变量，就会共享该类型的变量。 3.递归必须要有退出递归的条件，否则就无限递归了。 4.当一个方法执行完毕时，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也执行完毕。 递归用于解决的问题：8皇后问题,汉诺塔,阶乘问题,迷宫问题,快排,归并,二分查找,分治算法。 列子：迷宫问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) &#123; int [][] map=new int[8][7]; // 使用1表示为墙 map[3][1]=1; map[3][2]=1; for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); // 输出地图 System.out.println(\"地图的情况\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; //1. map 表示地图 //2. i,j 表示从地图的哪个位置开始出发 (1,1) //3. 如果小球能到 map[7][6] 位置，则说明通路找到. //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int [][]map,int i,int j)&#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2; // 假定该点是可以走通. if(setWay(map, i+1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay(map, i-1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"递归","slug":"数据结构/递归","permalink":"https://haikulou1.github.io/categories/数据结构/递归/"},{"name":"回溯","slug":"数据结构/递归/回溯","permalink":"https://haikulou1.github.io/categories/数据结构/递归/回溯/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"递归","slug":"递归","permalink":"https://haikulou1.github.io/tags/递归/"},{"name":"回溯","slug":"回溯","permalink":"https://haikulou1.github.io/tags/回溯/"}]},{"title":"数据结构之中缀表达式转后缀表达式","slug":"中缀表达式转后缀表达式","date":"2019-09-19T07:52:12.000Z","updated":"2019-09-20T13:48:14.962Z","comments":true,"path":"2019/09/19/中缀表达式转后缀表达式/","link":"","permalink":"https://haikulou1.github.io/2019/09/19/中缀表达式转后缀表达式/","excerpt":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –.","text":"中缀表达式 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法. 后缀表达式 后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –. 算法思路1.初始化两个栈：运算符栈s1和储存中间结果的栈s2； 2.从左至右扫描中缀表达式； 3.遇到操作数时，将其压s2； 4.遇到运算符时，比较其与s1栈顶运算符的优先级： (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1； (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； 5.遇到括号时： (1) 如果是左括号“(”，则直接压入s1. (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃. 6.重复步骤2至5，直到表达式的最右边. 7.将s1中剩余的运算符依次弹出并压入s2. 8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式. 举列说明中缀表达式为：1+((2+3)*4)-5 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Mid2End &#123;private static int ADD = 1;private static int SUB = 1;private static int MUL = 2;private static int DIV = 2;public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext()) &#123; String str = scanner.nextLine(); List&lt;String &gt;list=min2end(strtolist(str)); for(String s:list)&#123; System.out.print(s+\" \"); &#125; &#125;&#125; //1+((2+3)*4)-5 123+4*5-public static List&lt;String&gt; min2end(List&lt;String&gt; ls)&#123; Stack&lt;String&gt; s1=new Stack&lt;&gt;(); List&lt;String&gt;s2=new ArrayList&lt;&gt;(); for(String s:ls)&#123; if(s.matches(\"\\\\d+\")) &#123; s2.add(s); &#125;else if(s.equals(\"(\"))&#123; s1.push(s); &#125;else if(s.equals(\")\"))&#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while (!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125;else &#123; //当s的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 while(s1.size()!=0&amp;&amp;getValue(s)&lt;=getValue(s1.peek()))&#123; s2.add(s1.pop()); &#125; s1.push(s); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2;&#125; /** * 把数字和符号拆分出来 * @param s * @return */public static List&lt;String&gt; strtolist(String s)&#123; List&lt;String&gt; ls=new ArrayList&lt;&gt;(); int i=0; String str; char c; do &#123; if((c=s.charAt(i))&lt;48||(c=s.charAt(i))&gt;57)&#123; ls.add(c+\"\"); i++; &#125;else &#123; str=\"\"; while (i &lt; s.length() &amp;&amp;(c=s.charAt(i))&gt;=48&amp;&amp;(c=s.charAt(i))&lt;=57)&#123; str+=c; i++; &#125; ls.add(str); &#125; &#125;while (i&lt;s.length()); return ls;&#125;//写一个方法，返回对应的优先级数字public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; &#125; return result;&#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/categories/数据结构/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://haikulou1.github.io/categories/数据结构/栈/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://haikulou1.github.io/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"https://haikulou1.github.io/tags/栈/"}]}]}