<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骸の博客</title>
  
  <subtitle>每天进步一丢丢</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haikulou1.github.io/"/>
  <updated>2019-10-09T13:35:50.052Z</updated>
  <id>https://haikulou1.github.io/</id>
  
  <author>
    <name>胡歌的小迷弟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构排序之基数排序</title>
    <link href="https://haikulou1.github.io/2019/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/10/09/数据结构排序之基数排序/</id>
    <published>2019-10-09T12:37:23.000Z</published>
    <updated>2019-10-09T13:35:50.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Created by 胡歌的小迷弟 on 2019/9/25 16:12</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 基数排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> a[] = &#123; <span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">           sort(a);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">               System.out.println(a[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">           <span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">           <span class="keyword">int</span> max = arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                   max = arr[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//得到最大数是几位数</span></span><br><span class="line">           <span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">           <span class="comment">//说明</span></span><br><span class="line">           <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">           <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">           <span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">           <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">           <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">           <span class="comment">//可以这里理解</span></span><br><span class="line">           <span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">           <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//这里我们使用循环将代码处理</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">               <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                   <span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">                   <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                   <span class="comment">//放入到对应的桶中</span></span><br><span class="line">                   bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                   bucketElementCounts[digitOfElement]++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">               <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                   <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">                   <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                       <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                           <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                           arr[index++] = bucket[k][l];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">                   bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="https://haikulou1.github.io/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构排序之归并排序</title>
    <link href="https://haikulou1.github.io/2019/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/10/09/数据结构排序之归并排序/</id>
    <published>2019-10-09T12:08:50.000Z</published>
    <updated>2019-10-09T12:37:00.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列</li></ul><a id="more"></a><p><img src="http://py4grz9th.bkt.clouddn.com/%60RN$RVNACYHB9_8H7GPYM%60E.png" alt="hashcode" title="hashcode"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 胡歌的小迷弟 on 2019/10/9 20:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 归并排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        mergeSort(a,<span class="number">0</span>,a.length-<span class="number">1</span>,temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并的方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//(一)</span></span><br><span class="line">        <span class="comment">//先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">//继续</span></span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">//然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(二)</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://haikulou1.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构排序之快速排序</title>
    <link href="https://haikulou1.github.io/2019/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/10/08/数据结构排序之快速排序/</id>
    <published>2019-10-08T13:33:19.000Z</published>
    <updated>2019-10-08T13:36:07.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序基本思想"><a href="#快速排序基本思想" class="headerlink" title="快速排序基本思想"></a>快速排序基本思想</h2><ul><li>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<a id="more"></a></li></ul><p><img src="http://py4grz9th.bkt.clouddn.com/W%609%5D8S%60C4QW%7D0Q4%5BTAIU%60OK.png" alt="hashcode" title="hashcode"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 胡歌的小迷弟 on 2019/10/8 20:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 快速排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[]=&#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>&#125;;</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=left;</span><br><span class="line">        <span class="keyword">int</span> r=right;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line">            <span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line">            <span class="keyword">if</span>( l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">            sort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">            sort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序基本思想&quot;&gt;&lt;a href=&quot;#快速排序基本思想&quot; class=&quot;headerlink&quot; title=&quot;快速排序基本思想&quot;&gt;&lt;/a&gt;快速排序基本思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://haikulou1.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构排序之希尔排序</title>
    <link href="https://haikulou1.github.io/2019/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/10/08/数据结构排序之希尔排序/</id>
    <published>2019-10-08T13:26:02.000Z</published>
    <updated>2019-10-08T13:32:40.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</li></ul><a id="more"></a><p><img src="http://py4grz9th.bkt.clouddn.com/O%291%5DL_SNY~%257K~Z%289%5BX8Y5Y.png" alt="hashcode" title="hashcode"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 希尔排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a=&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                        <span class="comment">//移动</span></span><br><span class="line">                        arr[j] = arr[j-gap];</span><br><span class="line">                        j -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://haikulou1.github.io/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之排序之插入排序</title>
    <link href="https://haikulou1.github.io/2019/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/09/25/数据结构之排序之插入排序/</id>
    <published>2019-09-25T11:56:24.000Z</published>
    <updated>2019-09-26T01:24:04.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>插入排序的基本思想是:把n个待排序的元素看出一个有序表和一个无序表，开始是有序表只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p> <a id="more"></a><p> <img src="http://py4grz9th.bkt.clouddn.com/3%5BIR%291TGE5%29MBL%5DBRLT%25%280W.png" alt="hashcode" title="hashcode"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 胡歌的小迷弟 on 2019/9/25 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">10</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">        insertSort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用for循环来把代码简化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            insertVal=arr[i];</span><br><span class="line">            insertIndex=i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;arr[insertIndex])&#123;</span><br><span class="line">                arr[insertIndex+<span class="number">1</span>]=arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(insertIndex!=i+<span class="number">1</span>)&#123;</span><br><span class="line">                arr[insertIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println("第"+i+"轮插入");</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;p&gt;插入排序的基本思想是:把n个待排序的元素看出一个有序表和一个无序表，开始是有序表只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://haikulou1.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之排序之选择排序</title>
    <link href="https://haikulou1.github.io/2019/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/09/25/数据结构之排序之选择排序/</id>
    <published>2019-09-25T09:07:55.000Z</published>
    <updated>2019-10-06T02:18:03.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>每一趟在后面n-i-1个代排元素选取关键字最小的元素。</li></ul><p><img src="http://py4grz9th.bkt.clouddn.com/1569413332%281%29.jpg" alt="hashcode" title="hashcode"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimSelcet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[]=&#123;<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> tmep=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            index=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;a[index])&#123;</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index!=i)&#123;</span><br><span class="line">                    tmep=a[i];</span><br><span class="line">                    a[i]=a[index];</span><br><span class="line">                    a[index]=tmep;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单选择排序&quot;&gt;&lt;a href=&quot;#简单选择排序&quot; class=&quot;headerlink&quot; title=&quot;简单选择排序&quot;&gt;&lt;/a&gt;简单选择排序&lt;/h2&gt;&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="https://haikulou1.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之排序之冒泡排序</title>
    <link href="https://haikulou1.github.io/2019/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://haikulou1.github.io/2019/09/25/数据结构之排序之冒泡排序/</id>
    <published>2019-09-25T08:06:57.000Z</published>
    <updated>2019-09-25T12:11:46.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>通过比较相邻的关键字间的大小，来对相应关键字的顺序进行交换，每趟排序都能找出最大或者最小的关键字放在数组末尾。</li></ul><p><img src="http://py4grz9th.bkt.clouddn.com/1569413408%281%29.jpg" alt="hashcode" title="hashcode"></p> <a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 胡歌的小迷弟 on 2019/9/25 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maopaosort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">10</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp=a[j];</span><br><span class="line">                    a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序的小优化"><a href="#冒泡排序的小优化" class="headerlink" title="冒泡排序的小优化"></a>冒泡排序的小优化</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 胡歌的小迷弟 on 2019/9/25 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maopaosort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">10</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">false</span>; <span class="comment">//判断当前循环是否有交换</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                    temp=a[j];</span><br><span class="line">                    a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//在一次交换中没有一次交换发生过</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;<span class="comment">//重置flag，进行下次判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;h3 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通过比较相邻的关键字间的大小，来对相应关键字的顺序进行交换，每趟排序都能找出最大或者最小的关键字放在数组末尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://py4grz9th.bkt.clouddn.com/1569413408%281%29.jpg&quot; alt=&quot;hashcode&quot; title=&quot;hashcode&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://haikulou1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://haikulou1.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>java基础之集合之set之HashSet</title>
    <link href="https://haikulou1.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%E4%B9%8Bset%E4%B9%8BHashSet/"/>
    <id>https://haikulou1.github.io/2019/09/25/java基础之集合之set之HashSet/</id>
    <published>2019-09-25T02:59:31.000Z</published>
    <updated>2019-09-25T03:00:25.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li>哈希表边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法 如果 equls结果为true ，HashSet就视为同一个元素。如果equals 为false就不是同一个元素。 哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。左图表示hashCode值不相同的情况；右图表示hashCode值相同，但equals不相同的情况。</li></ul><p><img src="http://py4grz9th.bkt.clouddn.com/1569240786%281%29.jpg" alt="hashcode" title="hashcode"></p><ul><li>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashSet&quot;&gt;&lt;a href=&quot;#HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashSet&quot;&gt;&lt;/a&gt;HashSet&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;哈希表边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显
      
    
    </summary>
    
    
      <category term="java" scheme="https://haikulou1.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    
      <category term="HashSet" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/HashSet/"/>
    
    
      <category term="java" scheme="https://haikulou1.github.io/tags/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://haikulou1.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="HashSet" scheme="https://haikulou1.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>java基础之集合之Map之HashMap</title>
    <link href="https://haikulou1.github.io/2019/09/23/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%E4%B9%8BHashMap/"/>
    <id>https://haikulou1.github.io/2019/09/23/java基础之集合之HashMap/</id>
    <published>2019-09-23T11:48:14.000Z</published>
    <updated>2019-10-08T02:49:31.843Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Set注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。</p><a id="more"></a></li></ul><p><img src="http://py4grz9th.bkt.clouddn.com/1569240059%281%29.jpg" alt="集合之间的关系" title="集合之间的关系"></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap的结构"><a href="#HashMap的结构" class="headerlink" title="HashMap的结构"></a>HashMap的结构</h3><h4 id="jdk1-7与1-8不同点"><a href="#jdk1-7与1-8不同点" class="headerlink" title="jdk1.7与1.8不同点"></a>jdk1.7与1.8不同点</h4><p><img src="http://py4grz9th.bkt.clouddn.com/6S%7DOWSCX404G0%5D%25NG85KGOX.png" alt="hashmap1.7" title="hashmap1.7"></p><p><img src="http://py4grz9th.bkt.clouddn.com/1569378750%281%29.jpg" alt="hashmap1.8" title="hashmap1.8"></p><p>（1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</p><p>（2）扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1）</p><p>（3）而在JDK1.8的时候，用扩容前的原始位置+扩容的大小值的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。</p><p><img src="http://py4grz9th.bkt.clouddn.com/1569378607%281%29.jpg" alt="hashmap1" title="hashmap1"></p><p>扩容流程对比图:</p><p><img src="http://py4grz9th.bkt.clouddn.com/1569378633%281%29.jpg" alt="hashmap2" title="hashmap2"></p><ul><li>JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率）</li></ul><p><img src="http://py4grz9th.bkt.clouddn.com/1569378656%281%29.jpg" alt="hashmap3" title="hashmap3"></p><ul><li>为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键<br><img src="http://py4grz9th.bkt.clouddn.com/1569380178%281%29.jpg" alt="hashmap4" title="hashmap4"></li></ul><ul><li>为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化<br><img src="http://py4grz9th.bkt.clouddn.com/1569380149%281%29.jpg" alt="hashmap5" title="hashmap5"></li></ul><p>参考：<a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Set注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haikulou1.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    
      <category term="HashMap" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/HashMap/"/>
    
    
      <category term="java" scheme="https://haikulou1.github.io/tags/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://haikulou1.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="HashMap" scheme="https://haikulou1.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>java基础之集合之List</title>
    <link href="https://haikulou1.github.io/2019/09/22/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%E4%B9%8BList/"/>
    <id>https://haikulou1.github.io/2019/09/22/java基础之集合之List/</id>
    <published>2019-09-22T12:45:50.000Z</published>
    <updated>2019-09-23T11:45:49.598Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://py4grz9th.bkt.clouddn.com/1569156695%281%29.jpg" alt="List" title="集合之间的关系"></p> <a id="more"></a><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除</li></ul><h3 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h3><p>1.当我们new 一个ArrayList时，不传size时，往list中add第一个数据时，ArrayList就会new一个默认大小为10的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>2.当继续往list添加数据时,当添加的数据大于当前数组的大小时，就会将旧数组的数据复制到一个1.5倍大小的新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//newCapacity =1.5*oldCapacity</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>3.然而删除数据不会自动缩容</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</li></ul><h3 id="底层实现原理-1"><a href="#底层实现原理-1" class="headerlink" title="底层实现原理"></a>底层实现原理</h3><p>1.当我们new 一个 Vector时，就会自动创建一个默认大小为10的的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Vector中的方法是同步的。Vector的所有操作方法都被同步了，既然被同步了，多个线程就不可能同时访问vector中的数据，只能一个一个地访问，所以不会出现数据混乱的情况，所以是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> elementData.length;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the number of components in this vector.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  the number of components in this vector</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> elementCount;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Tests if this vector has no components.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if and only if this vector has</span></span><br><span class="line"><span class="comment">  *          no components, that is, its size is zero;</span></span><br><span class="line"><span class="comment">  *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> elementCount == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li></ul><p> 1.底层使用双向链表实现<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">      E item;</span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.item = element;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">          <span class="keyword">this</span>.prev = prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://py4grz9th.bkt.clouddn.com/1569156695%281%29.jpg&quot; alt=&quot;List&quot; title=&quot;集合之间的关系&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haikulou1.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://haikulou1.github.io/tags/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://haikulou1.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java基础之集合</title>
    <link href="https://haikulou1.github.io/2019/09/22/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://haikulou1.github.io/2019/09/22/java基础之集合/</id>
    <published>2019-09-22T12:09:50.000Z</published>
    <updated>2019-09-22T12:44:40.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合类存在放java.util包中，主要有set，list，map。</p><ol><li><p>Collection：Collection是集合List、Set、Queue的最基本的接口。</p></li><li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </p></li><li><p>Map：是映射表的基础接口</p><a id="more"></a></li></ol><p>集合之间继承和实现关系:</p><p><img src="http://py4grz9th.bkt.clouddn.com/1569154457%281%29.jpg" alt="集合之间的关系" title="集合之间的关系"></p><p><img src="http://py4grz9th.bkt.clouddn.com/%5BKVJI%7DY%5D%60DO$%29AIPA7LEA9Q.png" alt="集合之间的关系" title="集合之间的关系"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;集合类存在放java.util包中，主要有set，list，map。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Collection：Collection是集合List、Set、Queue的最基本的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iterator：迭代器，可以通过迭代器遍历集合中的数据 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Map：是映射表的基础接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haikulou1.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://haikulou1.github.io/tags/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>递归之8皇后问题</title>
    <link href="https://haikulou1.github.io/2019/09/22/%E9%80%92%E5%BD%92%E4%B9%8B8%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://haikulou1.github.io/2019/09/22/递归之8皇后问题/</id>
    <published>2019-09-22T12:02:16.000Z</published>
    <updated>2019-09-22T12:07:35.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="八皇后问题介绍"><a href="#八皇后问题介绍" class="headerlink" title="八皇后问题介绍"></a>八皇后问题介绍</h2><ul><li>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</li></ul><a id="more"></a><h2 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h2><p>1.第一个皇后先放第一行第一列</p><p>2.第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p><p>3.继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p><p>4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p><p>5.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> array[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">"一共有%d解法"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">8</span>) &#123;  <span class="comment">//n = 8 , 其实8个皇后就既然放好</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个皇后,即开始递归</span></span><br><span class="line">                check(n+<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 说明</span></span><br><span class="line">            <span class="comment">//1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line">            <span class="comment">// n = 1  放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line">            <span class="comment">// Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line">            <span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[n]==array[i]||(Math.abs(i-n)==Math.abs(array[n]-array[i])))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;八皇后问题介绍&quot;&gt;&lt;a href=&quot;#八皇后问题介绍&quot; class=&quot;headerlink&quot; title=&quot;八皇后问题介绍&quot;&gt;&lt;/a&gt;八皇后问题介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="https://haikulou1.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://haikulou1.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>java基础之基本特性</title>
    <link href="https://haikulou1.github.io/2019/09/21/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    <id>https://haikulou1.github.io/2019/09/21/java基础之基本特性/</id>
    <published>2019-09-21T13:16:16.000Z</published>
    <updated>2019-09-22T11:59:15.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>1.抽象</p><ul><li>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象有哪些行为，并不关心这些行为的细节是什么。</li></ul><a id="more"></a><p>2.继承</p><ul><li>继承是从已有类别得到继承信息创建新类的过程，提供继承信息的类被称为父类（超类，基类），得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</li></ul><p>3.多态</p><ul><li><p>多态是指允许不同子类型的对象对同一消息做出不同的反应</p><p>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不<br>同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方<br>法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><p> 重写（override)又名覆盖:</p><p> 1.不能存在同一个类中，在继承或实现关系的类中；</p><p> 2.名相同，参数列表相同，方法返回值相同，</p><p> 3.子类方法的访问修饰符要大于父类的。</p><p> 4.子类的检查异常类型要小于父类的检查异常。</p><p>重载（overload）</p><p> 1.可以在一个类中也可以在继承关系的类中；</p><p> 2.名相同；</p><p> 3.参数列表不同（个数，顺序，类型） 和方法的返回值类型无关。</p></li></ul><p>4.封装</p><ul><li>封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本特性&quot;&gt;&lt;a href=&quot;#基本特性&quot; class=&quot;headerlink&quot; title=&quot;基本特性&quot;&gt;&lt;/a&gt;基本特性&lt;/h2&gt;&lt;p&gt;1.抽象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象有哪些行为，并不关心这些行为的细节是什么。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haikulou1.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://haikulou1.github.io/tags/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础(基本数据类型)</title>
    <link href="https://haikulou1.github.io/2019/09/21/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://haikulou1.github.io/2019/09/21/java基础/</id>
    <published>2019-09-21T12:33:14.000Z</published>
    <updated>2019-09-21T13:16:51.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-8种基本类型"><a href="#java-8种基本类型" class="headerlink" title="java 8种基本类型"></a>java 8种基本类型</h2><table><thead><tr><th>类型</th><th align="center">在内存中占的字节数</th><th align="right">默认值</th></tr></thead><tbody><tr><td>boolean</td><td align="center">1</td><td align="right">false</td></tr><tr><td>byte</td><td align="center">1</td><td align="right">0</td></tr><tr><td>short</td><td align="center">2</td><td align="right">0</td></tr><tr><td>int</td><td align="center">4</td><td align="right">0</td></tr><tr><td>long</td><td align="center">8</td><td align="right">0</td></tr><tr><td>char</td><td align="center">1</td><td align="right">\u0000</td></tr><tr><td>float</td><td align="center">4</td><td align="right">0.0f</td></tr><tr><td>double</td><td align="center">8</td><td align="right">0.0d</td></tr></tbody></table><a id="more"></a><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><ul><li>自动装箱是Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比<br>如：把int 转化成Integer，double 转化成Double，等等。反之就是自动拆箱。</li></ul><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><h2 id="Int-与Integer-区别"><a href="#Int-与Integer-区别" class="headerlink" title="Int 与Integer 区别"></a>Int 与Integer 区别</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>Integer是int的包装类，int则是java的一种基本数据类型。</p></li><li><p>Integer变量必须实例化后才能使用，而int变量不需要。</p></li><li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值。</p></li><li><p>Integer的默认值是null，int的默认值是0。</p></li></ul><h3 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h3><p>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、对于两个非<span class="keyword">new</span>生成的Integer对象，进行比较时，如果两个变量的值在区间-<span class="number">128</span>到<span class="number">127</span>之间，则比较结果为<span class="keyword">true</span>，如果两个变量的值不在此区间，则比较结果为<span class="keyword">false</span></span><br><span class="line">```java</span><br><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p><h2 id="字节字符区别"><a href="#字节字符区别" class="headerlink" title="字节字符区别"></a>字节字符区别</h2><p>字节是存储容量的基本单位，字符是数子，字母，汉子以及其他语言的各种符号。<br>1 字节=8 个二进制单位：一个一个字符由一个字节或多个字节的二进制单位组成。</p><h2 id="java-基本类型与引用类型的区别"><a href="#java-基本类型与引用类型的区别" class="headerlink" title="java 基本类型与引用类型的区别"></a>java 基本类型与引用类型的区别</h2><p>基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所<br>处的位置/地址)</p><p>详情:<a href="https://blog.csdn.net/qq_26737667/article/details/91398154" target="_blank" rel="noopener">https://blog.csdn.net/qq_26737667/article/details/91398154</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-8种基本类型&quot;&gt;&lt;a href=&quot;#java-8种基本类型&quot; class=&quot;headerlink&quot; title=&quot;java 8种基本类型&quot;&gt;&lt;/a&gt;java 8种基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;在内存中占的字节数&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;\u0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0d&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haikulou1.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://haikulou1.github.io/tags/java/"/>
    
      <category term="java基础" scheme="https://haikulou1.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://haikulou1.github.io/2019/09/21/%E9%80%92%E5%BD%921/"/>
    <id>https://haikulou1.github.io/2019/09/21/递归1/</id>
    <published>2019-09-21T02:59:54.000Z</published>
    <updated>2019-09-22T12:00:09.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。</p><a id="more"></a><h2 id="递归调用机制"><a href="#递归调用机制" class="headerlink" title="递归调用机制"></a>递归调用机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       test(<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i&gt;<span class="number">2</span>)&#123;</span><br><span class="line">           test(i-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="http://py4grz9th.bkt.clouddn.com/2.png" alt="调用过程" title="调用过程"></p><h2 id="递归调用过程"><a href="#递归调用过程" class="headerlink" title="递归调用过程:"></a>递归调用过程:</h2><p>1.当程序进入到主函数时会在栈中开辟一个main函数的内存空间，继续调用test(4)。</p><p>2.当进入到test(4)时，这时i&gt;2,继续调用test(3),不会执行 System.out.println(i)。</p><p>3.依次继续执行直到i&lt;=2,这时会调用System.out.println(i);回调到test(3),直到回调到<br>test(4)函数，main函数执行结束，程序执行完毕。</p><h2 id="递归需要遵守的规则"><a href="#递归需要遵守的规则" class="headerlink" title="递归需要遵守的规则"></a>递归需要遵守的规则</h2><p>1.执行一个新的方法时，就会创建一个新的受保护的独立的栈空间，以便该方法保存本地原始值并引用该方法中的其他对象。</p><p>2.方法的局部变量是独立的，不会相互影响，如果方法中使用的是引用类型的变量，就会共享该类型的变量。</p><p>3.递归必须要有退出递归的条件，否则就无限递归了。</p><p>4.当一个方法执行完毕时，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也执行完毕。</p><h2 id="递归用于解决的问题："><a href="#递归用于解决的问题：" class="headerlink" title="递归用于解决的问题："></a>递归用于解决的问题：</h2><p>8皇后问题,汉诺塔,阶乘问题,迷宫问题,快排,归并,二分查找,分治算法。</p><h2 id="列子：迷宫问题"><a href="#列子：迷宫问题" class="headerlink" title="列子：迷宫问题"></a>列子：迷宫问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> [][] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">      <span class="comment">// 使用1表示为墙</span></span><br><span class="line">       map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">           map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">           map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 左右全部置为1</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">           map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">           map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line">       setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 输出地图</span></span><br><span class="line">       System.out.println(<span class="string">"地图的情况"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">               System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. map 表示地图</span></span><br><span class="line">   <span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">   <span class="comment">//3. 如果小球能到 map[7][6] 位置，则说明通路找到.</span></span><br><span class="line">   <span class="comment">//4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line">   <span class="comment">//5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i 从哪个位置开始找</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span> [][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line">               <span class="comment">//按照策略 下-&gt;右-&gt;上-&gt;左  走</span></span><br><span class="line">               map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line">               <span class="keyword">if</span>(setWay(map, i+<span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j+<span class="number">1</span>)) &#123; <span class="comment">//向右走</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i-<span class="number">1</span>, j)) &#123; <span class="comment">//向上</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j-<span class="number">1</span>))&#123; <span class="comment">// 向左走</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">                   map[i][j] = <span class="number">3</span>;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归的概念&quot;&gt;&lt;a href=&quot;#递归的概念&quot; class=&quot;headerlink&quot; title=&quot;递归的概念&quot;&gt;&lt;/a&gt;递归的概念&lt;/h2&gt;&lt;p&gt;简单的来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码更加简洁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="https://haikulou1.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://haikulou1.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之中缀表达式转后缀表达式</title>
    <link href="https://haikulou1.github.io/2019/09/19/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://haikulou1.github.io/2019/09/19/中缀表达式转后缀表达式/</id>
    <published>2019-09-19T07:52:12.000Z</published>
    <updated>2019-09-20T13:48:14.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><ul><li>是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法.</li></ul><h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><ul><li>后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –.</li></ul><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>1.初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p><p>2.从左至右扫描中缀表达式；</p><p>3.遇到操作数时，将其压s2；</p><p>4.遇到运算符时，比较其与s1栈顶运算符的优先级：</p><ul><li>(1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li><li>(2)否则，若优先级比栈顶运算符的高，也将运算符压入s1；</li><li>(3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</li></ul><p>5.遇到括号时：</p><ul><li><p>(1) 如果是左括号“(”，则直接压入s1.</p></li><li><p>(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃.</p></li></ul><p>6.重复步骤2至5，直到表达式的最右边.</p><p>7.将s1中剩余的运算符依次弹出并压入s2.</p><p>8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式.</p><h2 id="举列说明"><a href="#举列说明" class="headerlink" title="举列说明"></a>举列说明</h2><p>中缀表达式为：1+((2+3)*4)-5</p><p><img src="http://py4grz9th.bkt.clouddn.com/1.png" alt="转换过程" title="转换过程"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mid2End</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        String str = scanner.nextLine();</span><br><span class="line">        List&lt;String &gt;list=min2end(strtolist(str));</span><br><span class="line">        <span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">            System.out.print(s+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1+((2+3)*4)-5   123+4*5-</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">min2end</span><span class="params">(List&lt;String&gt; ls)</span></span>&#123;</span><br><span class="line">    Stack&lt;String&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    List&lt;String&gt;s2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s:ls)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">            s2.add(s);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">"("</span>))&#123;</span><br><span class="line">            s1.push(s);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">")"</span>))&#123;</span><br><span class="line">            <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">            <span class="keyword">while</span> (!s1.peek().equals(<span class="string">"("</span>))&#123;</span><br><span class="line">                s2.add(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            s1.pop();<span class="comment">//!!! 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当s的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span></span><br><span class="line">            <span class="keyword">while</span>(s1.size()!=<span class="number">0</span>&amp;&amp;getValue(s)&lt;=getValue(s1.peek()))&#123;</span><br><span class="line">                s2.add(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            s1.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line">    <span class="keyword">while</span>(s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        s2.add(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把数字和符号拆分出来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> List&lt;String&gt; <span class="title">strtolist</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; ls=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((c=s.charAt(i))&lt;<span class="number">48</span>||(c=s.charAt(i))&gt;<span class="number">57</span>)&#123;</span><br><span class="line">            ls.add(c+<span class="string">""</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp;(c=s.charAt(i))&gt;=<span class="number">48</span>&amp;&amp;(c=s.charAt(i))&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                str+=c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ls.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span> (i&lt;s.length());</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">            result = ADD;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">            result = SUB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">            result = MUL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">            result = DIV;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;中缀表达式&quot;&gt;&lt;a href=&quot;#中缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀表达式&quot;&gt;&lt;/a&gt;中缀表达式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例:3 + 4），中缀表达式是人们常用的算术表示方法.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;后缀表达式&quot;&gt;&lt;a href=&quot;#后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;后缀表达式&quot;&gt;&lt;/a&gt;后缀表达式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;后缀表达式也称逆波兰表达式，运算符位于操作数之后，(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="https://haikulou1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
    
    
      <category term="数据结构" scheme="https://haikulou1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="https://haikulou1.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
